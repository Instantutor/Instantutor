"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _posthtmlParser() {
  const data = _interopRequireDefault(require("posthtml-parser"));

  _posthtmlParser = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _posthtmlRender() {
  const data = _interopRequireDefault(require("posthtml-render"));

  _posthtmlRender = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _dependencies() {
  const data = _interopRequireDefault(require("./dependencies"));

  _dependencies = function () {
    return data;
  };

  return data;
}

function _inline() {
  const data = _interopRequireDefault(require("./inline"));

  _inline = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = new (_plugin().Transformer)({
  canReuseAST({
    ast
  }) {
    return ast.type === 'posthtml' && _semver().default.satisfies(ast.version, '^0.4.0');
  },

  async parse({
    asset
  }) {
    return {
      type: 'posthtml',
      version: '0.4.1',
      program: (0, _posthtmlParser().default)(await asset.getCode(), {
        lowerCaseAttributeNames: true,
        sourceLocations: true
      })
    };
  },

  async transform({
    asset,
    options
  }) {
    // Handle .htm
    asset.type = 'html';
    asset.bundleBehavior = 'isolated';
    let ast = (0, _nullthrows().default)(await asset.getAST());
    let hasScripts = (0, _dependencies().default)(asset, ast);
    const {
      assets: inlineAssets,
      hasScripts: hasInlineScripts
    } = (0, _inline().default)(asset, ast);
    const result = [asset, ...inlineAssets]; // empty <script></script> is added to make sure HMR is working even if user
    // didn't add any. It's inserted at the very end to take into account cases
    // when there's no html/head/body in source html.

    if (options.hmrOptions && !(hasScripts || hasInlineScripts)) {
      ast.program.push({
        tag: 'script',
        attrs: {
          src: asset.addURLDependency('hmr.js', {
            priority: 'parallel'
          })
        },
        content: []
      });
      asset.setAST(ast);
      result.push({
        type: 'js',
        content: '',
        uniqueKey: 'hmr.js'
      });
    }

    return result;
  },

  generate({
    ast
  }) {
    return {
      content: (0, _posthtmlRender().default)(ast.program)
    };
  }

});

exports.default = _default;