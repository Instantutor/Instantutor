"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dependencyToInternalDependency = dependencyToInternalDependency;
exports.default = void 0;

function _types() {
  const data = require("../types");

  _types = function () {
    return data;
  };

  return data;
}

function _Environment() {
  const data = _interopRequireDefault(require("./Environment"));

  _Environment = function () {
    return data;
  };

  return data;
}

function _Target() {
  const data = _interopRequireDefault(require("./Target"));

  _Target = function () {
    return data;
  };

  return data;
}

function _Symbols() {
  const data = require("./Symbols");

  _Symbols = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

const SpecifierTypeNames = Object.keys(_types().SpecifierType);
const PriorityNames = Object.keys(_types().Priority);
const inspect = Symbol.for('nodejs.util.inspect.custom');
const internalDependencyToDependency = new WeakMap();

const _dependencyToInternalDependency = new WeakMap();

function dependencyToInternalDependency(dependency) {
  return (0, _nullthrows().default)(_dependencyToInternalDependency.get(dependency));
}

var _dep = new WeakMap();

class Dependency {
  constructor(dep) {
    _dep.set(this, {
      writable: true,
      value: void 0
    });

    let existing = internalDependencyToDependency.get(dep);

    if (existing != null) {
      return existing;
    }

    _classPrivateFieldSet(this, _dep, dep);

    _dependencyToInternalDependency.set(this, dep);

    internalDependencyToDependency.set(dep, this);
    return this;
  } // $FlowFixMe


  [inspect]() {
    return `Dependency(${String(this.sourcePath)} -> ${this.specifier})`;
  }

  get id() {
    return _classPrivateFieldGet(this, _dep).id;
  }

  get specifier() {
    return _classPrivateFieldGet(this, _dep).specifier;
  }

  get specifierType() {
    return SpecifierTypeNames[_classPrivateFieldGet(this, _dep).specifierType];
  }

  get priority() {
    return PriorityNames[_classPrivateFieldGet(this, _dep).priority];
  }

  get needsStableName() {
    return _classPrivateFieldGet(this, _dep).needsStableName;
  }

  get bundleBehavior() {
    let bundleBehavior = _classPrivateFieldGet(this, _dep).bundleBehavior;

    return bundleBehavior == null ? null : _types().BundleBehaviorNames[bundleBehavior];
  }

  get isEntry() {
    return _classPrivateFieldGet(this, _dep).isEntry;
  }

  get isOptional() {
    return _classPrivateFieldGet(this, _dep).isOptional;
  }

  get loc() {
    return _classPrivateFieldGet(this, _dep).loc;
  }

  get env() {
    return new (_Environment().default)(_classPrivateFieldGet(this, _dep).env);
  }

  get meta() {
    return _classPrivateFieldGet(this, _dep).meta;
  }

  get symbols() {
    return new (_Symbols().MutableDependencySymbols)(_classPrivateFieldGet(this, _dep));
  }

  get target() {
    let target = _classPrivateFieldGet(this, _dep).target;

    return target ? new (_Target().default)(target) : null;
  }

  get sourceAssetId() {
    // TODO: does this need to be public?
    return _classPrivateFieldGet(this, _dep).sourceAssetId;
  }

  get sourcePath() {
    // TODO: does this need to be public?
    return _classPrivateFieldGet(this, _dep).sourcePath;
  }

  get sourceAssetType() {
    return _classPrivateFieldGet(this, _dep).sourceAssetType;
  }

  get resolveFrom() {
    var _classPrivateFieldGet2;

    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _dep).resolveFrom) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldGet(this, _dep).sourcePath;
  }

  get pipeline() {
    return _classPrivateFieldGet(this, _dep).pipeline;
  }

}

exports.default = Dependency;