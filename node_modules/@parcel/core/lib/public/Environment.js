"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.environmentToInternalEnvironment = environmentToInternalEnvironment;
exports.default = exports.BROWSER_ENVS = void 0;

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _browserslist() {
  const data = _interopRequireDefault(require("browserslist"));

  _browserslist = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

const BROWSER_ENVS = new Set(['browser', 'web-worker', 'service-worker', 'worklet', 'electron-renderer']);
exports.BROWSER_ENVS = BROWSER_ENVS;
const ELECTRON_ENVS = new Set(['electron-main', 'electron-renderer']);
const NODE_ENVS = new Set(['node', ...ELECTRON_ENVS]);
const WORKER_ENVS = new Set(['web-worker', 'service-worker']);
const ISOLATED_ENVS = new Set([...WORKER_ENVS, 'worklet']);
const ALL_BROWSERS = ['chrome', 'and_chr', 'edge', 'firefox', 'and_ff', 'safari', 'ios', 'samsung', 'opera', 'ie', 'op_mini', 'blackberry', 'op_mob', 'ie_mob', 'and_uc', 'and_qq', 'baidu', 'kaios'];
const supportData = {
  esmodules: {
    edge: '16',
    firefox: '60',
    chrome: '61',
    safari: '11',
    opera: '48',
    ios: '11',
    android: '76',
    and_chr: '76',
    and_ff: '68',
    samsung: '8.2'
  },
  'dynamic-import': {
    edge: '76',
    firefox: '67',
    chrome: '63',
    safari: '11.1',
    opera: '50',
    ios: '11.3',
    android: '63',
    and_chr: '63',
    and_ff: '67',
    samsung: '8'
  },
  'worker-module': {
    edge: '80',
    chrome: '80',
    opera: '67',
    android: '81',
    and_chr: '86'
  },
  'service-worker-module': {// TODO: Safari 14.1??
  }
};
const internalEnvironmentToEnvironment = new WeakMap();

const _environmentToInternalEnvironment = new WeakMap();

function environmentToInternalEnvironment(environment) {
  return (0, _nullthrows().default)(_environmentToInternalEnvironment.get(environment));
}

var _environment = new WeakMap();

class Environment {
  constructor(env) {
    _environment.set(this, {
      writable: true,
      value: void 0
    });

    let existing = internalEnvironmentToEnvironment.get(env);

    if (existing != null) {
      return existing;
    }

    _classPrivateFieldSet(this, _environment, env);

    _environmentToInternalEnvironment.set(this, env);

    internalEnvironmentToEnvironment.set(env, this);
    return this;
  }

  get id() {
    return _classPrivateFieldGet(this, _environment).id;
  }

  get context() {
    return _classPrivateFieldGet(this, _environment).context;
  }

  get engines() {
    return _classPrivateFieldGet(this, _environment).engines;
  }

  get includeNodeModules() {
    return _classPrivateFieldGet(this, _environment).includeNodeModules;
  }

  get outputFormat() {
    return _classPrivateFieldGet(this, _environment).outputFormat;
  }

  get sourceType() {
    return _classPrivateFieldGet(this, _environment).sourceType;
  }

  get isLibrary() {
    return _classPrivateFieldGet(this, _environment).isLibrary;
  }

  get shouldOptimize() {
    return _classPrivateFieldGet(this, _environment).shouldOptimize;
  }

  get shouldScopeHoist() {
    return _classPrivateFieldGet(this, _environment).shouldScopeHoist;
  }

  get sourceMap() {
    return _classPrivateFieldGet(this, _environment).sourceMap;
  }

  get loc() {
    return _classPrivateFieldGet(this, _environment).loc;
  }

  isBrowser() {
    return BROWSER_ENVS.has(_classPrivateFieldGet(this, _environment).context);
  }

  isNode() {
    return NODE_ENVS.has(_classPrivateFieldGet(this, _environment).context);
  }

  isElectron() {
    return ELECTRON_ENVS.has(_classPrivateFieldGet(this, _environment).context);
  }

  isIsolated() {
    return ISOLATED_ENVS.has(_classPrivateFieldGet(this, _environment).context);
  }

  isWorker() {
    return WORKER_ENVS.has(_classPrivateFieldGet(this, _environment).context);
  }

  isWorklet() {
    return _classPrivateFieldGet(this, _environment).context === 'worklet';
  }

  matchesEngines(minVersions, defaultValue = false) {
    // Determine if the environment matches some minimum version requirements.
    // For browsers, we run a browserslist query with and without the minimum
    // required browsers and compare the lists. For node, we just check semver.
    if (this.isBrowser() && this.engines.browsers != null) {
      let targetBrowsers = this.engines.browsers;
      let browsers = targetBrowsers != null && !Array.isArray(targetBrowsers) ? [targetBrowsers] : targetBrowsers; // If outputting esmodules, exclude browsers without support.

      if (this.outputFormat === 'esmodule') {
        browsers = [...browsers, ...getExcludedBrowsers(supportData.esmodules)];
      }

      let matchedBrowsers = (0, _browserslist().default)(browsers);
      let minBrowsers = getExcludedBrowsers(minVersions);
      let withoutMinBrowsers = (0, _browserslist().default)([...browsers, ...minBrowsers]);
      return matchedBrowsers.length === withoutMinBrowsers.length;
    } else if (this.isNode() && this.engines.node != null) {
      return minVersions.node != null && !_semver().default.intersects(`< ${minVersions.node}`, this.engines.node);
    }

    return defaultValue;
  }

  supports(feature, defaultValue) {
    let engines = supportData[feature];

    if (!engines) {
      throw new Error('Unknown environment feature: ' + feature);
    }

    return this.matchesEngines(engines, defaultValue);
  }

}

exports.default = Environment;

function getExcludedBrowsers(minVersions) {
  let browsers = [];

  for (let browser of ALL_BROWSERS) {
    let version = minVersions[browser];

    if (version) {
      browsers.push(`not ${browser} < ${version}`);
    } else {
      browsers.push(`not ${browser} > 0`);
    }
  }

  return browsers;
}