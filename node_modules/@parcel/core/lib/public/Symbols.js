"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MutableDependencySymbols = exports.MutableAssetSymbols = exports.AssetSymbols = void 0;

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

let _Symbol$iterator, _Symbol$iterator2, _Symbol$iterator3;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

const EMPTY_ITERABLE = {
  [Symbol.iterator]() {
    return EMPTY_ITERATOR;
  }

};
const EMPTY_ITERATOR = {
  next() {
    return {
      done: true
    };
  }

};
const inspect = Symbol.for('nodejs.util.inspect.custom');
let valueToSymbols = new WeakMap();

var _value = new WeakMap();

_Symbol$iterator = Symbol.iterator;

class AssetSymbols {
  /*::
  @@iterator(): Iterator<[ISymbol, {|local: ISymbol, loc: ?SourceLocation, meta?: ?Meta|}]> { return ({}: any); }
  */
  constructor(asset) {
    _value.set(this, {
      writable: true,
      value: void 0
    });

    let existing = valueToSymbols.get(asset);

    if (existing != null) {
      return existing;
    }

    _classPrivateFieldSet(this, _value, asset);

    valueToSymbols.set(asset, this);
    return this;
  }

  hasExportSymbol(exportSymbol) {
    var _classPrivateFieldGet2;

    return Boolean((_classPrivateFieldGet2 = _classPrivateFieldGet(this, _value).symbols) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.has(exportSymbol));
  }

  hasLocalSymbol(local) {
    if (_classPrivateFieldGet(this, _value).symbols == null) {
      return false;
    }

    for (let s of _classPrivateFieldGet(this, _value).symbols.values()) {
      if (local === s.local) return true;
    }

    return false;
  }

  get(exportSymbol) {
    var _classPrivateFieldGet3;

    return (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _value).symbols) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.get(exportSymbol);
  }

  get isCleared() {
    return _classPrivateFieldGet(this, _value).symbols == null;
  }

  exportSymbols() {
    var _classPrivateFieldGet4, _classPrivateFieldGet5;

    // $FlowFixMe
    return (_classPrivateFieldGet4 = (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _value).symbols) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.keys()) !== null && _classPrivateFieldGet4 !== void 0 ? _classPrivateFieldGet4 : [];
  } // $FlowFixMe


  [_Symbol$iterator]() {
    return _classPrivateFieldGet(this, _value).symbols ? _classPrivateFieldGet(this, _value).symbols[Symbol.iterator]() : EMPTY_ITERATOR;
  } // $FlowFixMe


  [inspect]() {
    return `AssetSymbols(${_classPrivateFieldGet(this, _value).symbols ? [..._classPrivateFieldGet(this, _value).symbols].map(([s, {
      local
    }]) => `${s}:${local}`).join(', ') : null})`;
  }

}

exports.AssetSymbols = AssetSymbols;
let valueToMutableAssetSymbols = new WeakMap();

var _value2 = new WeakMap();

_Symbol$iterator2 = Symbol.iterator;

class MutableAssetSymbols {
  /*::
  @@iterator(): Iterator<[ISymbol, {|local: ISymbol, loc: ?SourceLocation, meta?: ?Meta|}]> { return ({}: any); }
  */
  constructor(asset) {
    _value2.set(this, {
      writable: true,
      value: void 0
    });

    let existing = valueToMutableAssetSymbols.get(asset);

    if (existing != null) {
      return existing;
    }

    _classPrivateFieldSet(this, _value2, asset);

    return this;
  } // immutable


  hasExportSymbol(exportSymbol) {
    var _classPrivateFieldGet6;

    return Boolean((_classPrivateFieldGet6 = _classPrivateFieldGet(this, _value2).symbols) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.has(exportSymbol));
  }

  hasLocalSymbol(local) {
    if (_classPrivateFieldGet(this, _value2).symbols == null) {
      return false;
    }

    for (let s of _classPrivateFieldGet(this, _value2).symbols.values()) {
      if (local === s.local) return true;
    }

    return false;
  }

  get(exportSymbol) {
    return (0, _nullthrows().default)(_classPrivateFieldGet(this, _value2).symbols).get(exportSymbol);
  }

  get isCleared() {
    return _classPrivateFieldGet(this, _value2).symbols == null;
  }

  exportSymbols() {
    // $FlowFixMe
    return _classPrivateFieldGet(this, _value2).symbols.keys();
  } // $FlowFixMe


  [_Symbol$iterator2]() {
    return _classPrivateFieldGet(this, _value2).symbols ? _classPrivateFieldGet(this, _value2).symbols[Symbol.iterator]() : EMPTY_ITERATOR;
  } // $FlowFixMe


  [inspect]() {
    return `MutableAssetSymbols(${_classPrivateFieldGet(this, _value2).symbols ? [..._classPrivateFieldGet(this, _value2).symbols].map(([s, {
      local
    }]) => `${s}:${local}`).join(', ') : null})`;
  } // mutating


  ensure() {
    if (_classPrivateFieldGet(this, _value2).symbols == null) {
      _classPrivateFieldGet(this, _value2).symbols = new Map();
    }
  }

  set(exportSymbol, local, loc, meta) {
    (0, _nullthrows().default)(_classPrivateFieldGet(this, _value2).symbols).set(exportSymbol, {
      local,
      loc,
      meta
    });
  }

  delete(exportSymbol) {
    (0, _nullthrows().default)(_classPrivateFieldGet(this, _value2).symbols).delete(exportSymbol);
  }

}

exports.MutableAssetSymbols = MutableAssetSymbols;
let valueToMutableDependencySymbols = new WeakMap();

var _value3 = new WeakMap();

_Symbol$iterator3 = Symbol.iterator;

class MutableDependencySymbols {
  /*::
  @@iterator(): Iterator<[ISymbol, {|local: ISymbol, loc: ?SourceLocation, isWeak: boolean, meta?: ?Meta|}]> { return ({}: any); }
  */
  constructor(dep) {
    _value3.set(this, {
      writable: true,
      value: void 0
    });

    let existing = valueToMutableDependencySymbols.get(dep);

    if (existing != null) {
      return existing;
    }

    _classPrivateFieldSet(this, _value3, dep);

    return this;
  } // immutable:


  hasExportSymbol(exportSymbol) {
    var _classPrivateFieldGet7;

    return Boolean((_classPrivateFieldGet7 = _classPrivateFieldGet(this, _value3).symbols) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.has(exportSymbol));
  }

  hasLocalSymbol(local) {
    if (_classPrivateFieldGet(this, _value3).symbols) {
      for (let s of _classPrivateFieldGet(this, _value3).symbols.values()) {
        if (local === s.local) return true;
      }
    }

    return false;
  }

  get(exportSymbol) {
    return (0, _nullthrows().default)(_classPrivateFieldGet(this, _value3).symbols).get(exportSymbol);
  }

  get isCleared() {
    return _classPrivateFieldGet(this, _value3).symbols == null;
  }

  exportSymbols() {
    // $FlowFixMe
    return _classPrivateFieldGet(this, _value3).symbols ? _classPrivateFieldGet(this, _value3).symbols.keys() : EMPTY_ITERABLE;
  } // $FlowFixMe


  [_Symbol$iterator3]() {
    return _classPrivateFieldGet(this, _value3).symbols ? _classPrivateFieldGet(this, _value3).symbols[Symbol.iterator]() : EMPTY_ITERATOR;
  } // $FlowFixMe


  [inspect]() {
    return `MutableDependencySymbols(${_classPrivateFieldGet(this, _value3).symbols ? [..._classPrivateFieldGet(this, _value3).symbols].map(([s, {
      local,
      isWeak
    }]) => `${s}:${local}${isWeak ? '?' : ''}`).join(', ') : null})`;
  } // mutating:


  ensure() {
    if (_classPrivateFieldGet(this, _value3).symbols == null) {
      _classPrivateFieldGet(this, _value3).symbols = new Map();
    }
  }

  set(exportSymbol, local, loc, isWeak) {
    var _symbols$get$isWeak, _symbols$get;

    let symbols = (0, _nullthrows().default)(_classPrivateFieldGet(this, _value3).symbols);
    symbols.set(exportSymbol, {
      local,
      loc,
      isWeak: ((_symbols$get$isWeak = (_symbols$get = symbols.get(exportSymbol)) === null || _symbols$get === void 0 ? void 0 : _symbols$get.isWeak) !== null && _symbols$get$isWeak !== void 0 ? _symbols$get$isWeak : true) && (isWeak !== null && isWeak !== void 0 ? isWeak : false)
    });
  }

  delete(exportSymbol) {
    (0, _nullthrows().default)(_classPrivateFieldGet(this, _value3).symbols).delete(exportSymbol);
  }

}

exports.MutableDependencySymbols = MutableDependencySymbols;