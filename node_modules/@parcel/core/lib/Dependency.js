"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createDependency = createDependency;
exports.mergeDependencies = mergeDependencies;

function _hash() {
  const data = require("@parcel/hash");

  _hash = function () {
    return data;
  };

  return data;
}

function _types() {
  const data = require("./types");

  _types = function () {
    return data;
  };

  return data;
}

function createDependency(opts) {
  var _opts$sourceAssetId, _opts$pipeline, _opts$priority, _opts$needsStableName, _opts$isEntry, _opts$isOptional;

  let id = opts.id || (0, _hash().hashString)(((_opts$sourceAssetId = opts.sourceAssetId) !== null && _opts$sourceAssetId !== void 0 ? _opts$sourceAssetId : '') + opts.specifier + opts.env.id + (opts.target ? JSON.stringify(opts.target) : '') + ((_opts$pipeline = opts.pipeline) !== null && _opts$pipeline !== void 0 ? _opts$pipeline : ''));
  return { ...opts,
    id,
    specifierType: _types().SpecifierType[opts.specifierType],
    priority: _types().Priority[(_opts$priority = opts.priority) !== null && _opts$priority !== void 0 ? _opts$priority : 'sync'],
    needsStableName: (_opts$needsStableName = opts.needsStableName) !== null && _opts$needsStableName !== void 0 ? _opts$needsStableName : false,
    bundleBehavior: opts.bundleBehavior ? _types().BundleBehavior[opts.bundleBehavior] : null,
    isEntry: (_opts$isEntry = opts.isEntry) !== null && _opts$isEntry !== void 0 ? _opts$isEntry : false,
    isOptional: (_opts$isOptional = opts.isOptional) !== null && _opts$isOptional !== void 0 ? _opts$isOptional : false,
    meta: opts.meta || {},
    symbols: opts.symbols
  };
}

function mergeDependencies(a, b) {
  let {
    meta,
    symbols,
    ...other
  } = b;
  Object.assign(a, other);
  Object.assign(a.meta, meta);

  if (a.symbols && symbols) {
    for (let [k, v] of symbols) {
      a.symbols.set(k, v);
    }
  }
}