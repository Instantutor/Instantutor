"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createWorkerFarm = createWorkerFarm;
exports.BuildError = exports.default = exports.INTERNAL_RESOLVE = exports.INTERNAL_TRANSFORM = void 0;

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));

  _diagnostic = function () {
    return data;
  };

  return data;
}

function _Asset() {
  const data = require("./public/Asset");

  _Asset = function () {
    return data;
  };

  return data;
}

function _Bundle() {
  const data = require("./public/Bundle");

  _Bundle = function () {
    return data;
  };

  return data;
}

function _BundleGraph() {
  const data = _interopRequireDefault(require("./public/BundleGraph"));

  _BundleGraph = function () {
    return data;
  };

  return data;
}

function _workers() {
  const data = _interopRequireDefault(require("@parcel/workers"));

  _workers = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("./utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _ParcelConfigRequest() {
  const data = require("./requests/ParcelConfigRequest");

  _ParcelConfigRequest = function () {
    return data;
  };

  return data;
}

function _ReporterRunner() {
  const data = _interopRequireDefault(require("./ReporterRunner"));

  _ReporterRunner = function () {
    return data;
  };

  return data;
}

function _dumpGraphToGraphViz() {
  const data = _interopRequireDefault(require("./dumpGraphToGraphViz"));

  _dumpGraphToGraphViz = function () {
    return data;
  };

  return data;
}

function _resolveOptions() {
  const data = _interopRequireDefault(require("./resolveOptions"));

  _resolveOptions = function () {
    return data;
  };

  return data;
}

function _events() {
  const data = require("@parcel/events");

  _events = function () {
    return data;
  };

  return data;
}

function _cjsPonyfill() {
  const data = require("abortcontroller-polyfill/dist/cjs-ponyfill");

  _cjsPonyfill = function () {
    return data;
  };

  return data;
}

function _utils2() {
  const data = require("@parcel/utils");

  _utils2 = function () {
    return data;
  };

  return data;
}

function _ParcelConfig() {
  const data = _interopRequireDefault(require("./ParcelConfig"));

  _ParcelConfig = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("@parcel/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _RequestTracker() {
  const data = _interopRequireWildcard(require("./RequestTracker"));

  _RequestTracker = function () {
    return data;
  };

  return data;
}

function _ValidationRequest() {
  const data = _interopRequireDefault(require("./requests/ValidationRequest"));

  _ValidationRequest = function () {
    return data;
  };

  return data;
}

function _ParcelBuildRequest() {
  const data = _interopRequireDefault(require("./requests/ParcelBuildRequest"));

  _ParcelBuildRequest = function () {
    return data;
  };

  return data;
}

function _sourceMap() {
  const data = require("@parcel/source-map");

  _sourceMap = function () {
    return data;
  };

  return data;
}

function _hash() {
  const data = require("@parcel/hash");

  _hash = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get"); return _classApplyDescriptorGet(receiver, descriptor); }

function _classApplyDescriptorGet(receiver, descriptor) { if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set"); _classApplyDescriptorSet(receiver, descriptor, value); return value; }

function _classExtractFieldDescriptor(receiver, privateMap, action) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to " + action + " private field on non-instance"); } return privateMap.get(receiver); }

function _classApplyDescriptorSet(receiver, descriptor, value) { if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } }

(0, _utils().registerCoreWithSerializer)();
const INTERNAL_TRANSFORM = Symbol('internal_transform');
exports.INTERNAL_TRANSFORM = INTERNAL_TRANSFORM;
const INTERNAL_RESOLVE = Symbol('internal_resolve');
exports.INTERNAL_RESOLVE = INTERNAL_RESOLVE;

var _requestTracker = new WeakMap();

var _config = new WeakMap();

var _farm = new WeakMap();

var _initialized = new WeakMap();

var _disposable = new WeakMap();

var _initialOptions = new WeakMap();

var _reporterRunner = new WeakMap();

var _resolvedOptions = new WeakMap();

var _optionsRef = new WeakMap();

var _watchAbortController = new WeakMap();

var _watchQueue = new WeakMap();

var _watchEvents = new WeakMap();

var _watcherSubscription = new WeakMap();

var _watcherCount = new WeakMap();

var _requestedAssetIds = new WeakMap();

class Parcel {
  /*: RequestTracker*/

  /*: ParcelConfig*/

  /*: WorkerFarm*/

  /*: Disposable */

  /*: InitialParcelOptions*/

  /*: ReporterRunner*/

  /*: SharedReference */

  /*: AbortController*/

  /*: ValueEmitter<
  | {|
  +error: Error,
  +buildEvent?: void,
  |}
  | {|
  +buildEvent: BuildEvent,
  +error?: void,
  |},
  > */

  /*: ?AsyncSubscription*/
  constructor(options) {
    _requestTracker.set(this, {
      writable: true,
      value: void 0
    });

    _config.set(this, {
      writable: true,
      value: void 0
    });

    _farm.set(this, {
      writable: true,
      value: void 0
    });

    _initialized.set(this, {
      writable: true,
      value:
      /*: boolean*/
      false
    });

    _disposable.set(this, {
      writable: true,
      value: void 0
    });

    _initialOptions.set(this, {
      writable: true,
      value: void 0
    });

    _reporterRunner.set(this, {
      writable: true,
      value: void 0
    });

    _resolvedOptions.set(this, {
      writable: true,
      value:
      /*: ?ParcelOptions*/
      null
    });

    _optionsRef.set(this, {
      writable: true,
      value: void 0
    });

    _watchAbortController.set(this, {
      writable: true,
      value: void 0
    });

    _watchQueue.set(this, {
      writable: true,
      value:
      /*: PromiseQueue<?BuildEvent>*/
      new (_utils2().PromiseQueue)({
        maxConcurrent: 1
      })
    });

    _watchEvents.set(this, {
      writable: true,
      value: void 0
    });

    _watcherSubscription.set(this, {
      writable: true,
      value: void 0
    });

    _watcherCount.set(this, {
      writable: true,
      value:
      /*: number*/
      0
    });

    _requestedAssetIds.set(this, {
      writable: true,
      value:
      /*: Set<string>*/
      new Set()
    });

    _defineProperty(this, "isProfiling", void 0);

    _classPrivateFieldSet(this, _initialOptions, options);
  }

  async _init() {
    if (_classPrivateFieldGet(this, _initialized)) {
      return;
    }

    await _sourceMap().init;
    await _hash().init;
    let resolvedOptions = await (0, _resolveOptions().default)(_classPrivateFieldGet(this, _initialOptions));

    _classPrivateFieldSet(this, _resolvedOptions, resolvedOptions);

    let {
      config
    } = await (0, _ParcelConfigRequest().loadParcelConfig)(resolvedOptions);

    _classPrivateFieldSet(this, _config, new (_ParcelConfig().default)(config, resolvedOptions));

    if (_classPrivateFieldGet(this, _initialOptions).workerFarm) {
      if (_classPrivateFieldGet(this, _initialOptions).workerFarm.ending) {
        throw new Error('Supplied WorkerFarm is ending');
      }

      _classPrivateFieldSet(this, _farm, _classPrivateFieldGet(this, _initialOptions).workerFarm);
    } else {
      _classPrivateFieldSet(this, _farm, createWorkerFarm({
        shouldPatchConsole: resolvedOptions.shouldPatchConsole
      }));
    }

    if (resolvedOptions.cache.ensure) {
      await resolvedOptions.cache.ensure();
    }

    let {
      dispose: disposeOptions,
      ref: optionsRef
    } = await _classPrivateFieldGet(this, _farm).createSharedReference(resolvedOptions);

    _classPrivateFieldSet(this, _optionsRef, optionsRef);

    _classPrivateFieldSet(this, _disposable, new (_events().Disposable)());

    if (_classPrivateFieldGet(this, _initialOptions).workerFarm) {
      // If we don't own the farm, dispose of only these references when
      // Parcel ends.
      _classPrivateFieldGet(this, _disposable).add(disposeOptions);
    } else {
      // Otherwise, when shutting down, end the entire farm we created.
      _classPrivateFieldGet(this, _disposable).add(() => _classPrivateFieldGet(this, _farm).end());
    }

    _classPrivateFieldSet(this, _watchEvents, new (_events().ValueEmitter)());

    _classPrivateFieldGet(this, _disposable).add(() => _classPrivateFieldGet(this, _watchEvents).dispose());

    _classPrivateFieldSet(this, _requestTracker, await _RequestTracker().default.init({
      farm: _classPrivateFieldGet(this, _farm),
      options: resolvedOptions
    }));

    _classPrivateFieldSet(this, _reporterRunner, new (_ReporterRunner().default)({
      config: _classPrivateFieldGet(this, _config),
      options: resolvedOptions,
      workerFarm: _classPrivateFieldGet(this, _farm)
    }));

    _classPrivateFieldGet(this, _disposable).add(_classPrivateFieldGet(this, _reporterRunner));

    _classPrivateFieldSet(this, _initialized, true);
  }

  async run() {
    let startTime = Date.now();

    if (!_classPrivateFieldGet(this, _initialized)) {
      await this._init();
    }

    let result = await this._build({
      startTime
    });
    await this._end();

    if (result.type === 'buildFailure') {
      throw new BuildError(result.diagnostics);
    }

    return result;
  }

  async _end() {
    _classPrivateFieldSet(this, _initialized, false);

    await Promise.all([_classPrivateFieldGet(this, _disposable).dispose(), await _classPrivateFieldGet(this, _requestTracker).writeToCache()]);
    await _classPrivateFieldGet(this, _farm).callAllWorkers('clearConfigCache', []);
  }

  async _startNextBuild() {
    _classPrivateFieldSet(this, _watchAbortController, new (_cjsPonyfill().AbortController)());

    await _classPrivateFieldGet(this, _farm).callAllWorkers('clearConfigCache', []);

    try {
      let buildEvent = await this._build({
        signal: _classPrivateFieldGet(this, _watchAbortController).signal
      });

      _classPrivateFieldGet(this, _watchEvents).emit({
        buildEvent
      });

      return buildEvent;
    } catch (err) {
      // Ignore BuildAbortErrors and only emit critical errors.
      if (!(err instanceof _utils().BuildAbortError)) {
        throw err;
      }
    }
  }

  async watch(cb) {
    var _this$watcherCount;

    if (!_classPrivateFieldGet(this, _initialized)) {
      await this._init();
    }

    let watchEventsDisposable;

    if (cb) {
      watchEventsDisposable = _classPrivateFieldGet(this, _watchEvents).addListener(({
        error,
        buildEvent
      }) => cb(error, buildEvent));
    }

    if (_classPrivateFieldGet(this, _watcherCount) === 0) {
      _classPrivateFieldSet(this, _watcherSubscription, await this._getWatcherSubscription());

      await _classPrivateFieldGet(this, _reporterRunner).report({
        type: 'watchStart'
      }); // Kick off a first build, but don't await its results. Its results will
      // be provided to the callback.

      _classPrivateFieldGet(this, _watchQueue).add(() => this._startNextBuild());

      _classPrivateFieldGet(this, _watchQueue).run();
    }

    _classPrivateFieldSet(this, _watcherCount, (_this$watcherCount = +_classPrivateFieldGet(this, _watcherCount)) + 1), _this$watcherCount;
    let unsubscribePromise;

    const unsubscribe = async () => {
      var _this$watcherCount2;

      if (watchEventsDisposable) {
        watchEventsDisposable.dispose();
      }

      _classPrivateFieldSet(this, _watcherCount, (_this$watcherCount2 = +_classPrivateFieldGet(this, _watcherCount)) - 1), _this$watcherCount2;

      if (_classPrivateFieldGet(this, _watcherCount) === 0) {
        await (0, _nullthrows().default)(_classPrivateFieldGet(this, _watcherSubscription)).unsubscribe();

        _classPrivateFieldSet(this, _watcherSubscription, null);

        await _classPrivateFieldGet(this, _reporterRunner).report({
          type: 'watchEnd'
        });

        _classPrivateFieldGet(this, _watchAbortController).abort();

        await _classPrivateFieldGet(this, _watchQueue).run();
        await this._end();
      }
    };

    return {
      unsubscribe() {
        if (unsubscribePromise == null) {
          unsubscribePromise = unsubscribe();
        }

        return unsubscribePromise;
      }

    };
  }

  async _build({
    signal,
    startTime = Date.now()
  } = {}) {
    _classPrivateFieldGet(this, _requestTracker).setSignal(signal);

    let options = (0, _nullthrows().default)(_classPrivateFieldGet(this, _resolvedOptions));

    try {
      if (options.shouldProfile) {
        await this.startProfiling();
      }

      _classPrivateFieldGet(this, _reporterRunner).report({
        type: 'buildStart'
      });

      let request = (0, _ParcelBuildRequest().default)({
        optionsRef: _classPrivateFieldGet(this, _optionsRef),
        requestedAssetIds: _classPrivateFieldGet(this, _requestedAssetIds),
        signal
      });
      let {
        bundleGraph,
        bundleInfo,
        changedAssets,
        assetRequests
      } = await _classPrivateFieldGet(this, _requestTracker).runRequest(request, {
        force: true
      });

      _classPrivateFieldGet(this, _requestedAssetIds).clear(); // $FlowFixMe


      (0, _dumpGraphToGraphViz().default)(_classPrivateFieldGet(this, _requestTracker).graph, 'RequestGraph');
      let event = {
        type: 'buildSuccess',
        changedAssets: new Map(Array.from(changedAssets).map(([id, asset]) => [id, (0, _Asset().assetFromValue)(asset, options)])),
        bundleGraph: new (_BundleGraph().default)(bundleGraph, (bundle, bundleGraph, options) => _Bundle().PackagedBundle.getWithInfo(bundle, bundleGraph, options, bundleInfo.get(bundle.id)), options),
        buildTime: Date.now() - startTime,
        requestBundle: async bundle => {
          let bundleNode = bundleGraph._graph.getNodeByContentKey(bundle.id);

          (0, _assert().default)((bundleNode === null || bundleNode === void 0 ? void 0 : bundleNode.type) === 'bundle', 'Bundle does not exist');

          if (!bundleNode.value.isPlaceholder) {
            // Nothing to do.
            return {
              type: 'buildSuccess',
              changedAssets: new Map(),
              bundleGraph: event.bundleGraph,
              buildTime: 0,
              requestBundle: event.requestBundle
            };
          }

          for (let assetId of bundleNode.value.entryAssetIds) {
            _classPrivateFieldGet(this, _requestedAssetIds).add(assetId);
          }

          if (_classPrivateFieldGet(this, _watchQueue).getNumWaiting() === 0) {
            if (_classPrivateFieldGet(this, _watchAbortController)) {
              _classPrivateFieldGet(this, _watchAbortController).abort();
            }

            _classPrivateFieldGet(this, _watchQueue).add(() => this._startNextBuild());
          }

          let results = await _classPrivateFieldGet(this, _watchQueue).run();
          let result = results.filter(Boolean).pop();

          if (result.type === 'buildFailure') {
            throw new BuildError(result.diagnostics);
          }

          return result;
        }
      };
      await _classPrivateFieldGet(this, _reporterRunner).report(event);
      await _classPrivateFieldGet(this, _requestTracker).runRequest((0, _ValidationRequest().default)({
        optionsRef: _classPrivateFieldGet(this, _optionsRef),
        assetRequests
      }), {
        force: assetRequests.length > 0
      });
      return event;
    } catch (e) {
      if (e instanceof _utils().BuildAbortError) {
        throw e;
      }

      let diagnostic = (0, _diagnostic().anyToDiagnostic)(e);
      let event = {
        type: 'buildFailure',
        diagnostics: Array.isArray(diagnostic) ? diagnostic : [diagnostic]
      };
      await _classPrivateFieldGet(this, _reporterRunner).report(event);
      return event;
    } finally {
      if (this.isProfiling) {
        await this.stopProfiling();
      }
    }
  }

  async _getWatcherSubscription() {
    (0, _assert().default)(_classPrivateFieldGet(this, _watcherSubscription) == null);
    let resolvedOptions = (0, _nullthrows().default)(_classPrivateFieldGet(this, _resolvedOptions));
    let opts = (0, _RequestTracker().getWatcherOptions)(resolvedOptions);
    let sub = await resolvedOptions.inputFS.watch(resolvedOptions.projectRoot, (err, events) => {
      if (err) {
        _classPrivateFieldGet(this, _watchEvents).emit({
          error: err
        });

        return;
      }

      let isInvalid = _classPrivateFieldGet(this, _requestTracker).respondToFSEvents(events);

      if (isInvalid && _classPrivateFieldGet(this, _watchQueue).getNumWaiting() === 0) {
        if (_classPrivateFieldGet(this, _watchAbortController)) {
          _classPrivateFieldGet(this, _watchAbortController).abort();
        }

        _classPrivateFieldGet(this, _watchQueue).add(() => this._startNextBuild());

        _classPrivateFieldGet(this, _watchQueue).run();
      }
    }, opts);
    return {
      unsubscribe: () => sub.unsubscribe()
    };
  } // This is mainly for integration tests and it not public api!


  _getResolvedParcelOptions() {
    return (0, _nullthrows().default)(_classPrivateFieldGet(this, _resolvedOptions), 'Resolved options is null, please let parcel initialise before accessing this.');
  }

  async startProfiling() {
    if (this.isProfiling) {
      throw new Error('Parcel is already profiling');
    }

    _logger().default.info({
      origin: '@parcel/core',
      message: 'Starting profiling...'
    });

    this.isProfiling = true;
    await _classPrivateFieldGet(this, _farm).startProfile();
  }

  stopProfiling() {
    if (!this.isProfiling) {
      throw new Error('Parcel is not profiling');
    }

    _logger().default.info({
      origin: '@parcel/core',
      message: 'Stopping profiling...'
    });

    this.isProfiling = false;
    return _classPrivateFieldGet(this, _farm).endProfile();
  }

  takeHeapSnapshot() {
    _logger().default.info({
      origin: '@parcel/core',
      message: 'Taking heap snapshot...'
    });

    return _classPrivateFieldGet(this, _farm).takeHeapSnapshot();
  }

}

exports.default = Parcel;

class BuildError extends _diagnostic().default {
  constructor(diagnostic) {
    super({
      diagnostic
    });
    this.name = 'BuildError';
  }

}

exports.BuildError = BuildError;

function createWorkerFarm(options = {}) {
  return new (_workers().default)({ ...options,
    workerPath: require.resolve('./worker')
  });
}