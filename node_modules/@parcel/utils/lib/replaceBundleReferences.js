"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceURLReferences = replaceURLReferences;
exports.replaceInlineReferences = replaceInlineReferences;
exports.getURLReplacement = getURLReplacement;

function _stream() {
  const data = require("stream");

  _stream = function () {
    return data;
  };

  return data;
}

function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));

  _nullthrows = function () {
    return data;
  };

  return data;
}

function _url() {
  const data = _interopRequireDefault(require("url"));

  _url = function () {
    return data;
  };

  return data;
}

function _() {
  const data = require("./");

  _ = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Replaces references to dependency ids for URL dependencies with:
 *   - in the case of an unresolvable url dependency, the original specifier.
 *     These are external requests that Parcel did not bundle.
 *   - in the case of a reference to another bundle, the relative url to that
 *     bundle from the current bundle.
 */
function replaceURLReferences({
  bundle,
  bundleGraph,
  contents,
  map,
  relative = true
}) {
  let replacements = new Map();
  let urlDependencies = [];
  bundle.traverse(node => {
    if (node.type === 'dependency' && node.value.specifierType === 'url') {
      urlDependencies.push(node.value);
    }
  });

  for (let dependency of urlDependencies) {
    if (dependency.specifierType !== 'url') {
      continue;
    }

    let resolved = bundleGraph.getReferencedBundle(dependency, bundle);

    if (resolved == null) {
      replacements.set(dependency.id, {
        from: dependency.id,
        to: dependency.specifier
      });
      continue;
    }

    if (!resolved || resolved.bundleBehavior === 'inline') {
      // If a bundle is inline, it should be replaced with inline contents,
      // not a URL.
      continue;
    }

    replacements.set(dependency.id, getURLReplacement({
      dependency,
      fromBundle: bundle,
      toBundle: resolved,
      relative
    }));
  }

  return performReplacement(replacements, contents, map);
}
/*
 * Replaces references to dependency ids for inline bundles with the packaged
 * contents of that bundle.
 */


async function replaceInlineReferences({
  bundle,
  bundleGraph,
  contents,
  map,
  getInlineReplacement,
  getInlineBundleContents
}) {
  let replacements = new Map();
  let dependencies = [];
  bundle.traverse(node => {
    if (node.type === 'dependency') {
      dependencies.push(node.value);
    }
  });

  for (let dependency of dependencies) {
    let entryBundle = bundleGraph.getReferencedBundle(dependency, bundle);

    if ((entryBundle === null || entryBundle === void 0 ? void 0 : entryBundle.bundleBehavior) !== 'inline') {
      continue;
    }

    let packagedBundle = await getInlineBundleContents(entryBundle, bundleGraph);
    let packagedContents = (packagedBundle.contents instanceof _stream().Readable ? await (0, _().bufferStream)(packagedBundle.contents) : packagedBundle.contents).toString();
    let inlineType = (0, _nullthrows().default)(entryBundle.getMainEntry()).meta.inlineType;

    if (inlineType == null || inlineType === 'string') {
      replacements.set(dependency.id, getInlineReplacement(dependency, inlineType, packagedContents));
    }
  }

  return performReplacement(replacements, contents, map);
}

function getURLReplacement({
  dependency,
  fromBundle,
  toBundle,
  relative
}) {
  let to;

  if (relative) {
    to = _url().default.format(_url().default.parse((0, _().relativeBundlePath)(fromBundle, toBundle, {
      leadingDotSlash: false
    })));
  } else {
    to = (0, _().urlJoin)(toBundle.target.publicUrl, _url().default.format(_url().default.parse((0, _nullthrows().default)(toBundle.name))));
  }

  return {
    from: dependency.id,
    to
  };
}

function performReplacement(replacements, contents, map) {
  let finalContents = contents;

  for (let {
    from,
    to
  } of replacements.values()) {
    // Perform replacement
    finalContents = finalContents.split(from).join(to);
  }

  return {
    contents: finalContents,
    // TODO: Update sourcemap with adjusted contents
    map
  };
}