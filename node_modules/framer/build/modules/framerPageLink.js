import { computeRelativePath, isRoute, useCurrentRouteId, getRouteElementId } from "../router/index.js";
import { isString } from "../utils/utils.js";
function isTransition(value) {
    switch (value) {
        case "instant":
        case "push":
        case "fade":
            return true;
        default:
            return false;
    }
}
const framerPageLinkAttributeVerification = {
    transition: isTransition,
    element: isString,
};
// This includes the comma that separates the media type from the data.
const mediaType = "framer/page-link,";
/**
 * @internal
 */
export function isFramerPageLink(value) {
    return isString(value) && value.startsWith(`data:${mediaType}`);
}
/**
 * @internal
 */
export function createFramerPageLink(targetId = null, options = {}) {
    const target = targetId ? targetId : "none";
    const link = new URL(`data:${mediaType}${target}`);
    for (const optionKey in options)
        link.searchParams.append(optionKey, options[optionKey]);
    return link.href;
}
/**
 * @internal
 */
export function parseFramerPageLink(link) {
    if (!isFramerPageLink(link))
        return;
    try {
        const url = new URL(link);
        const target = url.pathname.substring(mediaType.length);
        const attributes = {};
        url.searchParams.forEach((value, key) => {
            if (key in framerPageLinkAttributeVerification)
                attributes[key] = value;
        });
        url.searchParams.delete("element");
        return {
            target: target === "none" ? null : target,
            element: attributes.element === "none" ? null : attributes.element,
            attributes,
            attributeString: url.search.substring(1),
        };
    }
    catch {
        return;
    }
}
/** A regex that searches for html tags, and href values. */
const regex = /(<([a-z]+)(?:\s+(?!href[\s=])[^=\s]+=(?:'[^']*'|"[^"]*"))*)(?:(\s+href\s*=)(?:'([^']*)'|"([^"]*)"))?((?:\s+[^=\s]+=(?:'[^']*'|"[^"]*"))*>)/gi;
/**
 * Escape html characters that would result in invalid paths.
 * https://www.30secondsofcode.org/js/s/escape-html
 */
const escapeHTML = (str) => str.replace(/[&<>'"]/g, tag => ({
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    "'": "&#39;",
    '"': "&quot;",
}[tag] || tag));
/**
 * @internal
 */
export function replaceFramerPageLinks(rawHTML, getRoute, currentRouteId) {
    return rawHTML.replace(regex, (original, pre1, tag, pre2, value1, value2, post) => {
        if (tag.toLowerCase() !== "a")
            return original;
        const pageLink = parseFramerPageLink(value1 || value2);
        if (!pageLink || !pageLink.target)
            return original;
        const targetRoute = getRoute(pageLink.target);
        const currentRoute = getRoute(currentRouteId);
        if (!isRoute(targetRoute) || !isRoute(currentRoute))
            return original;
        const targetPath = targetRoute.path;
        const currentPath = currentRoute.path;
        if (!targetPath || !currentPath)
            return original;
        let attributes = ` ${"data-framer-page-link-target" /* Page */}="${pageLink.target}" ${"data-framer-page-link-transition" /* Transition */}="${pageLink.attributeString}"`;
        const elementId = getRouteElementId(targetRoute, pageLink.element ?? undefined);
        if (elementId)
            attributes += ` ${"data-framer-page-link-element" /* Element */}="${pageLink.element}"`;
        const relativePath = computeRelativePath(currentPath, targetPath);
        return (pre1 + pre2 + `"${escapeHTML(relativePath + (elementId ? `#${elementId}` : ""))}"` + attributes + post);
    });
}
/**
 * @internal
 */
export function useLinkMatchesRoute(link) {
    const currentRouteId = useCurrentRouteId();
    if (!currentRouteId)
        return false;
    const pageLink = parseFramerPageLink(link);
    // If we allowed page links to be active when they had an element, all page
    // links that were to an element on the current page would always be active.
    // We don't want that, so for now, we ignore links with elements. In future,
    // maybe we can build a feature so that links to an element on the current
    // page are only active when the element is in view.
    return isFramerPageLink(link) && pageLink?.target === currentRouteId && !pageLink?.element;
}
//# sourceMappingURL=framerPageLink.js.map